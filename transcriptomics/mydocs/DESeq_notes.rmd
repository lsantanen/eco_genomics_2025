---
title: "DESeq2_tonsa_multigen"
author: "Lauren Santanen"
date: "2025-10-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydata")
```


```{r}
## Import the libraries that we're likely to need in this session

library(DESeq2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(ggpubr)
library(vsn)  
library("pheatmap")
library("vsn")

####################################################

### Import our data

####################################################

 
# Import the counts matrix
countsTable <- read.table("counts_matrix.txt", header=TRUE, row.names=1)
head(countsTable)
```


```{r}
dim(countsTable)
```

```{r}
countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
head(countsTableRound)
```

```{r}
#import the sample description table
conds <- read.delim("metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)
head(conds)
```
Explore data distributions

```{r}

# Let's see how many reads we have from each sample
colSums(countsTableRound)
```


```{r}
mean(colSums(countsTableRound))
```

Note that we are below the general rule of thumb recommendation of 20M reads per sample. We're at about 12M reads per sample

```{r}
barplot(colSums(countsTableRound), names.arg=colnames(countsTableRound),cex.names=0.5, las=3,ylim=c(0,21000000)) #change dims
abline(h=mean(colSums(countsTableRound)), col="blue", lwd=2)

```


```{r}
# the average number of counts per gene
rowSums(countsTableRound)
```

```{r}
mean(rowSums(countsTableRound)) # 

```

Despite lots of zeros across the 119,800 transcripts, we still have an average of 2500 reads mapping per transcript.

```{r}
median(rowSums(countsTableRound)) #
```


```{r}
apply(countsTableRound,2,mean) # 2 in the apply function does the action across columns
apply(countsTableRound,1,mean) # 1 in the apply function does the action across rows
```


```{r}
hist(apply(countsTableRound,1,mean),xlim=c(0,15000), ylim=c(0,100),breaks=10000)
```
#Now that we've explored the data, let's run DESeq2

```{r}

#Corrects the column names to match between the metadata table and the counts matrix
colnames(countsTableRound) <- substr(colnames(countsTableRound), start = 1, stop = 4)

####################################################

### Start working with DESeq2!

####################################################

#### Create a DESeq object and define the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ generation + line + generation:line)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 
# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression
dds <- DESeq(dds)

# List the results you've generated
resultsNames(dds)
# Copy the results names 
```
Continuing on 10/16/25

```{r}
# The goal of transformation "is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low."

# this gives log2(n + 1)
ntd <- normTransform(dds)
meanSdPlot(assay(ntd))

# Variance stabilizing transformation
vsd <- vst(dds, blind=FALSE)
meanSdPlot(assay(vsd))

```

Use the variance stabilized data to make plots
Look for outliers

```{r}
sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$line, vsd$generation, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

# Note any outliers
```
Make a cluster tree to look for outlier samples 

```{r}
sampleTree <- hclust(dist(sampleDists), method="average")
# plot
plot(sampleTree, main="Sample clustering to detect outliers", sub="", xlab="",cex.lab=1.5, cex.axis=1.5, cex.main=2)
```

On to PCA...

```{r}
# first transform the data for plotting using variance stabilization
vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("line","generation"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=line, shape=generation)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
```

Optimizing data visualization
Added in additional detail
Points are bigger, added shapes and indicated what they are, treatments are blue vs red

```{r}
ggplot(pcaData, aes(PC1, PC2)) +
  geom_point(size=5, stroke = 1, aes(fill=line, shape=generation, alpha = generation)) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_shape_manual(values=c(21,22,23,24), labels = c("G1", "G2","G3", "G4"))+
  #scale_shape_manual(values=c(21,22,23,24) -> circle, square, diamond, triangle
  scale_fill_manual(values=c('#6699CC',"#CC3333"), labels = c("Control", "Treatment"))+
  scale_alpha_manual(values = c(1.0, 0.8, 0.7, 0.3), guide = "none") +
  theme_bw() +
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 3))+
  theme(text = element_text(size = 20)) +
  theme(legend.title = element_blank())
```
Differential gene expression testing
Making groups to test specific contrasts

```{r}
dds$line <- relevel(dds$line, ref = "control")
dds$generation <- relevel(dds$generation, ref = "G1")


dds$group <- factor(paste0(dds$line, dds$generation))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)

```

Pull out results of interest using control generation 1 and treatment generation 1 with a sig value of .05

Can change the order that the contrast is in (control and treatment) and the log2FoldChange will switch signs

```{r}
resG1_CvT <- results(dds, contrast=c("group","controlG1","treatmentG1"), alpha = 0.05)

summary(resG1_CvT)
```
Reorder by significance

```{r}
resG1_CvT <- resG1_CvT[order(resG1_CvT$padj),]
head(resG1_CvT)
```

Plot individual genes

```{r}
# Counts of specific top interaction gene! (important validatition that the normalization, model is working)
d <-plotCounts(dds, gene="TRINITY_DN136145_c6_g8_i4", intgroup = (c("line","generation")), returnData=TRUE)
d

d$generation <- factor(d$generation, levels = sort(unique(d$generation)))

p <- ggplot(d, aes(x = generation, y = count, color = line, group = line)) +
  theme_minimal() + theme(text = element_text(size=20), panel.grid.major=element_line(colour="grey"))
p <- p + geom_point(position=position_jitter(w=0.2,h=0), size=3, aes(shape = line)) 
p <- p + stat_summary(fun = mean, geom = "point", size=5, alpha=0.7) 
p <- p + stat_summary(fun = mean, geom = "line", size = 1.5, aes(group = line), alpha = 0.8)
p <- p + scale_color_manual(values = c("control" = "blue", "treatment" = "red"))
p
```

Make an MA plot
Question: What is the relationship between LFC and magnitude of expression?

Gray points are not significantly differentially expressed and blue points are the ones that are.

Triangles signify that there are points beyond the bounds of the graph.
```{r}
plotMA(resG1_CvT, ylim=c(-5,5))
```


Make a volcano plot
Question: What is the relationship between LFC and significance of DGE?
```{r}
# Make a dataframe
res_df <- as.data.frame(resG1_CvT)

# Remove NAs
res_df <- res_df[!is.na(res_df$padj), ]

# Add significance column for color mapping
res_df$significance <- "Not Sig"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange > 0] <- "Up"
res_df$significance[res_df$padj < 0.05 & res_df$log2FoldChange < 0] <- "Down"

ggplot(res_df, aes(x = log2FoldChange, y = -log10(padj), color = significance)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = c("Up" = "blue", "Down" = "red", "Not Sig" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(
    title = "Volcano Plot: Generation 1 (Treatment vs Control)",
    x = expression(log[2]~Fold~Change),
    y = expression(-log[10]~Adjusted~p~value)
  ) +
  theme_bw(base_size = 16) +
  theme(legend.title = element_blank())
```


Make a heatmap of top 20 genes sorted by p-value

Question: For DEGs, what does gene expression variation look like across individual samples among treatment groups?

```{r}
topgenes <- head(rownames(resG1_CvT),100)
mat <- assay(vsd)[topgenes,]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(dds)[,c("generation","line")])
pheatmap(mat, annotation_col=df)
pheatmap(mat, annotation_col=df, cluster_cols = F)
```

Let’s make plots to explore differentially expressed genes between CvsT across generations

First step: Identify the DEGs in the contrast for control versus treatment for each generation

```{r}
#Gen1
resG1_CvT <- results(dds, contrast=c("group","controlG1","treatmentG1"), alpha = 0.05)
resG1_CvT <- resG1_CvT[order(resG1_CvT$padj),] #sort
head(resG1_CvT)
summary(resG1_CvT)

resG1_CvT <- resG1_CvT[!is.na(resG1_CvT$padj),]
degs_G1_CvTM <- row.names(resG1_CvT[resG1_CvT$padj < 0.05,])

#Gen2
resG2_CvT <- results(dds, contrast=c("group","controlG2","treatmentG2"), alpha = 0.05)
resG2_CvT <- resG2_CvT[order(resG2_CvT$padj),] #sort
head(resG2_CvT)
summary(resG2_CvT)

resG2_CvT <- resG2_CvT[!is.na(resG2_CvT$padj),]
degs_G2_CvTM <- row.names(resG2_CvT[resG2_CvT$padj < 0.05,])

#Gen3
resG3_CvT <- results(dds, contrast=c("group","controlG3","treatmentG3"), alpha = 0.05)
resG3_CvT <- resG3_CvT[order(resG3_CvT$padj),] #sort
head(resG3_CvT)
summary(resG3_CvT)

resG3_CvT <- resG3_CvT[!is.na(resG3_CvT$padj),]
degs_G3_CvTM <- row.names(resG3_CvT[resG3_CvT$padj < 0.05,])

#Gen4
resG4_CvT <- results(dds, contrast=c("group","controlG4","treatmentG4"), alpha = 0.05)
resG4_CvT <- resG4_CvT[order(resG4_CvT$padj),] #sort
head(resG4_CvT)
summary(resG4_CvT)

resG4_CvT <- resG4_CvT[!is.na(resG4_CvT$padj),]
degs_G4_CvTM <- row.names(resG4_CvT[resG4_CvT$padj < 0.05,])
```

## Make a heatmap of G1 sig genes and how they change across generations

Question: How does gene expression change across generations for the genes that are initially differentially expressed in Generation 1 (between different developmental temperatures, 18 vs. 22 C)

```{r}
sig_genes_G1 <- rownames(resG1_CvT[which(resG1_CvT$padj < 0.05 & !is.na(resG1_CvT$padj)), ])

# Combine into a data frame
lfc_mat <- data.frame(
  Gen1 = resG1_CvT[sig_genes_G1, "log2FoldChange"],
  Gen2 = resG2_CvT[sig_genes_G1, "log2FoldChange"],
  Gen3 = resG3_CvT[sig_genes_G1, "log2FoldChange"],
  Gen4 = resG4_CvT[sig_genes_G1, "log2FoldChange"]
)

# Remove any rows with missing values (some genes may not be in all result tables)
lfc_mat <- na.omit(lfc_mat)

pheatmap(lfc_mat,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC (Treatment vs Control) of Sig Genes in Gen 1")
```

The above focuses on the G1 genes, try to make one thet focuses on the G2 genes

```{r}
sig_genes_G2 <- rownames(resG2_CvT[which(resG2_CvT$padj < 0.05 & !is.na(resG2_CvT$padj)), ])

# Combine into a data frame
lfc_mat2 <- data.frame(
  Gen1 = resG1_CvT[sig_genes_G2, "log2FoldChange"],
  Gen2 = resG2_CvT[sig_genes_G2, "log2FoldChange"],
  Gen3 = resG3_CvT[sig_genes_G2, "log2FoldChange"],
  Gen4 = resG4_CvT[sig_genes_G2, "log2FoldChange"]
)

# Remove any rows with missing values (some genes may not be in all result tables)
lfc_mat <- na.omit(lfc_mat2)

pheatmap(lfc_mat2,
         scale = "row",             # scales each gene’s LFCs across generations
         color = colorRampPalette(c("blue", "white", "red"))(50),
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "complete",
         show_rownames = FALSE,
         main = "LFC (Treatment vs Control) of Sig Genes in Gen 2")
```

## Here we can make a Venn or Euler plot

Question: How much overlap is there between genes differentially expressed between treatments across generations?

```{r}
library(eulerr)

# Total
length(degs_G1_CvTM)  # 573
length(degs_G2_CvTM)  # 4568
length(degs_G3_CvTM)  # 1234
length(degs_G4_CvTM)  # 40

# Intersections
length(intersect(degs_G1_CvTM,degs_G2_CvTM))  # 227
length(intersect(degs_G1_CvTM,degs_G3_CvTM))  # 71
#length(intersect(degs_G1_CvTM,degs_G4_CvTM)) 

length(intersect(degs_G2_CvTM,degs_G3_CvTM))  # 294
#length(intersect(degs_G2_CvTM,degs_G4_CvTM))  

#length(intersect(degs_G3_CvTM,degs_G4_CvTM)) 

# To calc number shared in all three contrasts
int12 <- intersect(degs_G1_CvTM,degs_G2_CvTM)
length(intersect(degs_G3_CvTM,int12)) # 13

# Number unique

573 - 227 - 71 + 13   #  G1 288
4568 - 227 - 294 + 13 #  G2 4060
1234 - 71 - 294 + 13  #  G3 882


227 - 13 # G1&G2 214
71 - 13  # G1&G3 58
294 - 13 # G2&G3 281

# Note that the names are important and have to be specific to line up the diagram
fit1 <- euler(c("G1" = 288, "G2" = 4060, "G3" = 882, "G1&G2" = 214, "G1&G3" = 58, "G2&G3" = 281, "G1&G2&G3" = 13))


plot(fit1,  lty = 1:3, quantities = TRUE)
# lty changes the lines

plot(fit1, quantities = TRUE, fill = "transparent",
     lty = 1:3,
     labels = list(font = 4))


#cross check
 #  total G1
 #  total G2
 #  total G3
```

