---
title: "DESeq2toTopGO"
author: "Lauren Santanen"
date: "2025-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir="/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydata")
```

Import libraries and dara and run DESeq2 to generate the results we need for testing for functional enrichment
```{r}

## Import the libraries that we're likely to need in this session

library(DESeq2)
library(dplyr)
library(tibble)
library(topGO)
library(GO.db)
library(ggplot2)
library(scales) 
 
# Import the counts matrix
countsTable <- read.table("counts_matrix.txt", header=TRUE, row.names=1)
dim(countsTable)

countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
# Corrects the column names to match between the metadata table and the counts matrix.
colnames(countsTableRound) <- substr(colnames(countsTableRound), start=1, stop = 4)

#import the sample description table
conds <- read.delim("metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)


#### Create a DESeq object and define the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ generation + line)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 
# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression

dds$line <- relevel(dds$line, ref = "control")
dds$generation <- relevel(dds$generation, ref = "G1")

dds$group <- factor(paste0(dds$line, dds$generation))
design(dds) <- ~ group
dds <- DESeq(dds)
resultsNames(dds)


#Gen1
resG1_CvT <- results(dds, contrast=c("group","controlG1","treatmentG1"), alpha = 0.05)
resG1_CvT <- resG1_CvT[order(resG1_CvT$padj),] #sort
resG1_CvT <- resG1_CvT[!is.na(resG1_CvT$padj),]

#Gen2
resG2_CvT <- results(dds, contrast=c("group","controlG2","treatmentG2"), alpha = 0.05)
resG2_CvT <- resG2_CvT[order(resG2_CvT$padj),] #sort
resG2_CvT <- resG2_CvT[!is.na(resG2_CvT$padj),]

#Gen3
resG3_CvT <- results(dds, contrast=c("group","controlG3","treatmentG3"), alpha = 0.05)
resG3_CvT <- resG3_CvT[order(resG3_CvT$padj),] #sort
resG3_CvT <- resG3_CvT[!is.na(resG3_CvT$padj),]

#Gen4
resG4_CvT <- results(dds, contrast=c("group","controlG4","treatmentG4"), alpha = 0.05)
resG4_CvT <- resG4_CvT[order(resG4_CvT$padj),] #sort
resG4_CvT <- resG4_CvT[!is.na(resG4_CvT$padj),]
```

Before we jump in, what do the distributions of our results look like?
```{r}
library(ggplot2)
library(ggpubr)

# Convert results to data frame and clean
res_df <- as.data.frame(resG1_CvT)
res_df <- res_df[!is.na(res_df$padj), ]

# Calculate and add -log10(padj)
res_df$negLog10Padj <- -log10(res_df$padj)

# Panel 1: padj distribution
p1 <- ggplot(res_df, aes(x = padj)) +
  geom_histogram(bins = 50, fill = "skyblue3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Adjusted p-values (padj)") +
  xlab("padj") +
  ylab("Count")

# Panel 2: -log10(padj)
p2 <- ggplot(res_df, aes(x = negLog10Padj)) +
  geom_histogram(bins = 50, fill = "tomato3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("-log10(padj)") +
  xlab("-log10(padj)") +
  ylab("Count")

# Panel 3: Wald Statistic
p3 <- ggplot(res_df, aes(x = stat)) +
  geom_histogram(bins = 50, fill = "seagreen3", color = "black") +
  theme_minimal(base_size = 16) +
  ggtitle("Wald Statistic") +
  xlab("stat") +
  ylab("Count")

# Combine vertically with ggpubr
combined_plot <- ggarrange(
  p1, p2, p3,
  ncol = 1, nrow = 3,
  labels = c("A", "B", "C"),  # optional panel labels
  align = "v",                # vertical alignment
  common.legend = FALSE
)

# Show combined plot
combined_plot
```
And what are the relationships between these metrics?

```{r}
# Panel D: Wald statistic vs -log10(padj) scatter 
p4 <- ggplot(res_df, aes(x = pvalue, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "yellow4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("P-value vs -log10(padj)") +
  xlab("P-value") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")

# Panel E: Wald statistic vs -log10(padj) scatter 
p5 <- ggplot(res_df, aes(x = stat, y = negLog10Padj)) +
  geom_point(alpha = 0.4, color = "purple4") + ylim(c(0,5)) +
  theme_minimal(base_size = 8) +
  ggtitle("Wald Statistic vs -log10(padj)") +
  xlab("Wald statistic") +
  ylab("-log10(padj)") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black")


combined_plot <- ggarrange(
  p4, p5,
  ncol = 2, nrow = 1,
  align = "h"
)

# Show combined plot
combined_plot
```
Let’s make a density plot with a rugplot below to understand what we’re testing in a functional enrichment test.

```{r}
ggplot(res_df, aes(x = negLog10Padj)) +
  geom_density(fill = "lightblue", color = "blue", alpha = 0.5, linewidth = 1) + xlim(c(0,5)) +
  geom_rug(sides = "b", color = "gray30", alpha = 0.5) +
  geom_vline(xintercept = -log10(0.05), linetype = "dashed", color = "red") +
  theme_minimal(base_size = 8) +
  xlab(expression(-log[10](padj))) +
  ylab("Density") +
  ggtitle(expression("Density of " * -log[10](padj)))
```

Go in gen order, so start with G1

```{r}

# Convert to data frame
res_G1_df <- as.data.frame(resG1_CvT)

# Add geneID column from rownames
res_G1_df$geneID <- rownames(res_G1_df)
res_G1_df <- res_G1_df[, c("geneID", setdiff(names(res_G1_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G1_GO <- res_G1_df[res_G1_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G1_GO_sig <- subset(res_G1_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G1_tonsa_stat <- merge(res_G1_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G1_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G1 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G1_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G1_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen1")
topGO_plot

####################################################################
# Step 1: generate a vector of GO terms that represent the enriched set from your topGO or ReviGO analysis
G1_GOenrich = G1_res_table[which(G1_res_table$classicFisher<0.05),"GO.ID"]

# Step 2: map the GO terms from your enriched set back to the tonsa gene IDs
G1_GOGenes = names(gene2GO[which((gene2GO %in% G1_GOenrich)==TRUE)])


# Step 3: Use the gene IDs that represent genes associated with significantly enriched GO terms and pull out the logFC values from the DESeq results for plotting
G1_GO_LFC = res_G1_df[which(res_G1_df$geneID %in% G1_GOGenes),]

G2_GO_LFC = res_G2_df[which(res_G2_df$geneID %in% G1_GOGenes),]

G1G2merged = as.data.frame(cbind(G1_GO_LFC$log2FoldChange,G2_GO_LFC$log2FoldChange))
names(G1G2merged) = c("G1_LFC","G2_LFC")

#plot(G1G2merged$G1_LFC,G1G2merged$G2_LFC)

#ggplot(G1G2merged,aes(x=G1_LFC,y=G2_LFC)) +
  #geom_point()



ggplot(G1G2merged, aes(x = G1_LFC, y = G2_LFC)) +
  theme_minimal(base_size = 10) +
  ggtitle("LFC DEGs G1 vs G2") +
  xlab("G1_LFC") +
  ylab("G2_LFC") +
  geom_point()


```

Output the enrichment results from TopGO and try REViGO - make sure to rename the files for each gen!
```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")]

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydocs/G1topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```


########################################################################
Move onto Gen2 (this is the same code from class - we know it has the most differentially expressed genes)

```{r}

# Convert to data frame
res_G2_df <- as.data.frame(resG2_CvT)

# Add geneID column from rownames
res_G2_df$geneID <- rownames(res_G2_df)
res_G2_df <- res_G2_df[, c("geneID", setdiff(names(res_G2_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydata/Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G2_GO <- res_G2_df[res_G2_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G2_GO_sig <- subset(res_G2_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G2_tonsa_stat <- merge(res_G2_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G2_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G2 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G2_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G2_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen2")
topGO_plot

###################################################################
# Step 1: generate a vector of GO terms that represent the enriched set from your topGO or ReviGO analysis
G2_GOenrich = G2_res_table[which(G2_res_table$classicFisher<0.05),"GO.ID"]

# Step 2: map the GO terms from your enriched set back to the tonsa gene IDs
G2_GOGenes = names(gene2GO[which((gene2GO %in% G2_GOenrich)==TRUE)])


# Step 3: Use the gene IDs that represent genes associated with significantly enriched GO terms and pull out the logFC values from the DESeq results for plotting
G2_GO_LFC = res_G2_df[which(res_G2_df$geneID %in% G2_GOGenes),]

G1_GO_LFC = res_G1_df[which(res_G1_df$geneID %in% G2_GOGenes),]

G2G1merged = as.data.frame(cbind(G2_GO_LFC$log2FoldChange,G1_GO_LFC$log2FoldChange))
names(G2G1merged) = c("G2_LFC","G1_LFC")

#plot(G1G2merged$G1_LFC,G1G2merged$G2_LFC)

#ggplot(G1G2merged,aes(x=G1_LFC,y=G2_LFC)) +
  #geom_point()



ggplot(G2G1merged, aes(x = G2_LFC, y = G1_LFC)) +
  theme_minimal(base_size = 10) +
  ggtitle("LFC DEGs G2 vs G1") +
  xlab("G2_LFC") +
  ylab("G1_LFC") +
  geom_point()


```

Output the enrichment results from TopGO and try REViGO - make sure to rename the files for each gen!

```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")]

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydocs/G2topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```



#########################################################################

Gen3 

```{r}
# Convert to data frame
res_G3_df <- as.data.frame(resG3_CvT)

# Add geneID column from rownames
res_G3_df$geneID <- rownames(res_G3_df)
res_G3_df <- res_G3_df[, c("geneID", setdiff(names(res_G3_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G3_GO <- res_G3_df[res_G3_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G3_GO_sig <- subset(res_G3_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G3_tonsa_stat <- merge(res_G3_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G3_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G3 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G3_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G3_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen3")
topGO_plot

```

Output the enrichment results from TopGO and try REViGO - make sure to rename the files for each gen!


```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")]

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydocs/G3topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```



########################################################################

Gen4
```{r}
# Convert to data frame
res_G4_df <- as.data.frame(resG4_CvT)

# Add geneID column from rownames
res_G4_df$geneID <- rownames(res_G4_df)
res_G4_df <- res_G4_df[, c("geneID", setdiff(names(res_G4_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G4_GO <- res_G4_df[res_G4_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G4_GO_sig <- subset(res_G4_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G4_tonsa_stat <- merge(res_G4_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G4_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G1 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G4_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G4_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen4")
topGO_plot

```

Output the enrichment results from TopGO and try REViGO - make sure to rename the files for each gen!


```{r}
# Select only the columns REVIGO needs
revigo_input <- filtered_GO_results[, c("GO.ID", "classicFisher")]

sigRes <- revigo_input[as.numeric(revigo_input$classicFisher) < 0.05, ]

# Rename columns for clarity
colnames(sigRes) <- c("GO.ID", "pValue")

# Save as txt to upload to REVIGO
write.table(sigRes, file = "/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydocs/G4topGOsig_for_REVIGO.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```






########################################################################
Create pdfs for the plots we need from this doc

```{r}
pdf("GO_Enrichment_AllGen.pdf",width=10,height=10)
par(mfrow=c(2,2))

#G1

# Convert to data frame
res_G1_df <- as.data.frame(resG1_CvT)

# Add geneID column from rownames
res_G1_df$geneID <- rownames(res_G1_df)
res_G1_df <- res_G1_df[, c("geneID", setdiff(names(res_G1_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G1_GO <- res_G1_df[res_G1_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G1_GO_sig <- subset(res_G1_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G1_tonsa_stat <- merge(res_G1_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G1_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G1 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G1_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G1_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen1")
topGO_plot
#########################################################################

#G2

# Convert to data frame
res_G2_df <- as.data.frame(resG2_CvT)

# Add geneID column from rownames
res_G2_df$geneID <- rownames(res_G2_df)
res_G2_df <- res_G2_df[, c("geneID", setdiff(names(res_G2_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("/users/l/s/lsantane/projects/eco_genomics_2025/transcriptomics/mydata/Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G2_GO <- res_G2_df[res_G2_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G2_GO_sig <- subset(res_G2_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G2_tonsa_stat <- merge(res_G2_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G2_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G2 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G2_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G2_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen2")
topGO_plot

#########################################################################

#G3

# Convert to data frame
res_G3_df <- as.data.frame(resG3_CvT)

# Add geneID column from rownames
res_G3_df$geneID <- rownames(res_G3_df)
res_G3_df <- res_G3_df[, c("geneID", setdiff(names(res_G3_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G3_GO <- res_G3_df[res_G3_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G3_GO_sig <- subset(res_G3_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G3_tonsa_stat <- merge(res_G3_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G3_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G3 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G3_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G3_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen3")
topGO_plot

########################################################################

#G4

# Convert to data frame
res_G4_df <- as.data.frame(resG4_CvT)

# Add geneID column from rownames
res_G4_df$geneID <- rownames(res_G4_df)
res_G4_df <- res_G4_df[, c("geneID", setdiff(names(res_G4_df), "geneID"))]

# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Identify DEGs that have GO annotations
res_G4_GO <- res_G4_df[res_G4_df$geneID %in% tonsa_go$geneID, ]

# identify significant DEGs 
res_G4_GO_sig <- subset(res_G4_GO, padj < 0.05 & abs(log2FoldChange) > 1)


# Merge with GO annotations
G4_tonsa_stat <- merge(res_G4_GO_sig, tonsa_go, by = "geneID")

# Create gene2GO list which is used in the topgo function 
gene2GO <- tonsa_go %>%
  filter(!is.na(GO) & GO != "") %>%
  group_by(geneID) %>%
  summarise(GO = list(unique(GO)), .groups = "drop") %>%
  with(setNames(GO, geneID))

# Split semicolon-separated GO terms
gene2GO <- lapply(gene2GO, function(x) unlist(strsplit(x, ";")))

# Create geneList for TopGO: 1 = DEG, 0 = not DEG
all_genes <- names(gene2GO)
geneList <- setNames(as.integer(all_genes %in% G4_tonsa_stat$geneID), all_genes)

#Build TopGO pipeline 
GOdata <- new("topGOdata",
              description = "G1 DEGs GO enrichment",
              ontology = "BP",
              allGenes = geneList,
              geneSel = function(x) x == 1,
              nodeSize = 5,
              annot = annFUN.gene2GO,
              gene2GO = gene2GO)

#test for enrichment 
result <- runTest(GOdata, algorithm = "parentChild", statistic = "fisher")

# Convert results to table
G4_res_table <- GenTable(GOdata, classicFisher = result,
                      topNodes = length(usedGO(GOdata))) %>%
  mutate(classicFisher = as.numeric(classicFisher),
         Annotated = as.numeric(Annotated),
         Significant = as.numeric(Significant))

#plot!

# Keep GO terms with enough but not too many genes
filtered_GO_results <- G4_res_table %>%
  filter(Annotated >= 5 & Annotated < 500) %>%  # adjust as needed
  group_by(Term) %>%
  slice_min(classicFisher, n = 1) %>%  # keep only the most significant per Term
  ungroup() %>%
  arrange(classicFisher)


TopGO_plot <- function(df, title) {
  df %>%
    slice_head(n = 30) %>%
    ggplot(aes(x = -log10(classicFisher),
               y = reorder(Term, -log10(classicFisher)),
               size = Significant,
               color = -log10(classicFisher))) +
    geom_point(alpha = 0.8) +
    scale_color_gradientn(
      colors = c("pink", "orchid", "purple", "purple4"),
      name = "-log10(p-value)"
    ) +
    scale_size_continuous(name = "# Significant Genes") +
    xlab("-log10-classicFisher") +
    ylab("Biological Function") +
    ggtitle(title) +
    theme_minimal() +
    theme(plot.margin = margin(10, 100, 10, 10),
          axis.text.y = element_text(size = 10, hjust = 1)) +
    coord_cartesian(clip = "off")
}

# Generate plot
topGO_plot <- TopGO_plot(filtered_GO_results, "GO Enrichment for DEGs at Gen4")
topGO_plot

dev.off()

```

Combine the LFC plots
```{r}

pdf("LFC.pdf",width=10,height=10)
par(mfrow=c(1,2))

#G1

# Step 1: generate a vector of GO terms that represent the enriched set from your topGO or ReviGO analysis
G1_GOenrich = G1_res_table[which(G1_res_table$classicFisher<0.05),"GO.ID"]

# Step 2: map the GO terms from your enriched set back to the tonsa gene IDs
G1_GOGenes = names(gene2GO[which((gene2GO %in% G1_GOenrich)==TRUE)])


# Step 3: Use the gene IDs that represent genes associated with significantly enriched GO terms and pull out the logFC values from the DESeq results for plotting
G1_GO_LFC = res_G1_df[which(res_G1_df$geneID %in% G1_GOGenes),]

G2_GO_LFC = res_G2_df[which(res_G2_df$geneID %in% G1_GOGenes),]

G1G2merged = as.data.frame(cbind(G1_GO_LFC$log2FoldChange,G2_GO_LFC$log2FoldChange))
names(G1G2merged) = c("G1_LFC","G2_LFC")


ggplot(G1G2merged, aes(x = G1_LFC, y = G2_LFC)) +
  theme_minimal(base_size = 10) +
  ggtitle("LFC DEGs G1 vs G2") +
  xlab("G1_LFC") +
  ylab("G2_LFC") +
  geom_point()


########################################################################

#G2

# Step 1: generate a vector of GO terms that represent the enriched set from your topGO or ReviGO analysis
G2_GOenrich = G2_res_table[which(G2_res_table$classicFisher<0.05),"GO.ID"]

# Step 2: map the GO terms from your enriched set back to the tonsa gene IDs
G2_GOGenes = names(gene2GO[which((gene2GO %in% G2_GOenrich)==TRUE)])


# Step 3: Use the gene IDs that represent genes associated with significantly enriched GO terms and pull out the logFC values from the DESeq results for plotting
G2_GO_LFC = res_G2_df[which(res_G2_df$geneID %in% G2_GOGenes),]

G1_GO_LFC = res_G1_df[which(res_G1_df$geneID %in% G2_GOGenes),]

G2G1merged = as.data.frame(cbind(G2_GO_LFC$log2FoldChange,G1_GO_LFC$log2FoldChange))
names(G2G1merged) = c("G2_LFC","G1_LFC")


ggplot(G2G1merged, aes(x = G2_LFC, y = G1_LFC)) +
  theme_minimal(base_size = 10) +
  ggtitle("LFC DEGs G2 vs G1") +
  xlab("G2_LFC") +
  ylab("G1_LFC") +
  geom_point()

dev.off()

```

